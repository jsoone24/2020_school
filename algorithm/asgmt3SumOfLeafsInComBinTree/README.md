# 완전이진트리에서 리프노드 탐색 그 후 합 구하기
> ## input
1. 값의 총 개수 n이 주어진다.
2. 0~9 사이의 값들이 주어진다.
> ## 알고리즘 설계 방법
완전이진트리 생성
1. 이진트리의 루트노드에 해당하는 노드를 생성한다.
2. 파일에서 처음 주어지는 트리 전체 크기를 저장한다.
3. 이후 너비 탐색과 동일하게 주어지는 값을 하나씩 읽는다.
4. 너비 탐색을 하는 방법과 유사한 방법을 사용한다.
5. 먼저 루트 노드를 큐에 push한다.
6. 큐에서 pop을 하고 파일에서 값을 하나씩 읽어 node->val에 저장한다.
7. n이 0보다 크다면, Left, Right 순서로 새 노드를 만들어서 할당한다. 그리고 새로 만들어진 노드를 큐에 push한다.
8. n이 0보다 작다면, Left, Right 노드를 만드는 것을 멈추고 NULL값을 저장한다. 큐에 노드를 push하지 않는다.
9. 큐에 원소가 없을 때까지 반복한다.
10. 루트 노드를 따라가면 원소를 알아낼 수 있다.
### 리프노드까지 합
1. 전역 변수로 리턴 값을 저장할 result와, 트리를 내려가면서 합을 임시로 저장할 temp를 unsigned long long int형으로 선언한다. 초기화는 0으로 해준다.
2. 깊이 우선 탐색방식으로 트리를 탐색하며, 노드를 지나칠 때마다 temp에 temp * 10 + node->val 을 저장한다. temp에 여태까지 node->val이 각 자리에 있게 해준다.
3. 재귀를 이용해 함수에 left 노드를 넘겨주고 계속해서 탐색해 나간다.
4. 만약 노드의 left가 null이면 리프노드에 도달했다는 의미이므로 result에 result + temp * 10 + node->val값을 저장한다. 리프 노드 까지의 합들을 누적해서 저장한다. 
5. 완전 이진트리에서 left가 null이면 right도 null이므로 left가 null이면 right는 탐색하지 않는다. 그리고 함수가 종료된다.
6. 왼쪽을 모두 탐색한 뒤, right 노드가 null이 아니라면, 재귀를 이용해 함수에 right 노드를 넘겨주고 계속해서 탐색해 나간다. 리프노드에 도달하면 4.번의 동작을 수행하고 함수가 종료된다.
7. 트리의 left node, right node를 탐색하고 돌아오면, 현재 temp에 temp/10을 저장한다. 현재 노드까지 탐색을 마쳤기 때문에 temp에 저장된 값들의 자리수를 하나씩 당겨줘야 하기 때문이다.
8. 모든 재귀가 끝나서 함수가 종료되고나면, 전역변수 result에 루트에서 출발하여 리프에 도달하는 모든 경로의 값을 더한 값이 저장된다.
9. result를 return 한다.

> ## Correctness
### 완전이진트리 생성
LoopInvarient
- queue는 너비 우선 탐색의 순서로 노드가 push된다. 노드는 항상 완전이진트리를 만족하는 형태로 생성된다.

InductiveHypothesis
- queue에 너비우선 탐색 방식으로 노드가 push된다면, 너비 우선 탐색 순서로 입력되는 값에 대해 알맞은 자리를 찾아갈 수 있을 것이다. 그리고 노드가 항상 이진트리를 만족하는 형태로 생성될 것이다.

BaseCase
- 원소가 하나인 queue에는 노드 하나가 저장되어 있으며 노드 하나는 그 자체로 너비우선탐색으로 저장되었고, 완전이진트리를 만족한다.

InductiveStep
1. queue가 비어있지 않다면, queue의 가장 앞 원소를 pop한다. i번째 루프에 대해서 원소가 i개 남아있다. 이때 i가 0보다 크다면, 첫번재 조건문를 통해 left노드에 새 TreeNode를 할당하고, 큐에 새로 할당된 노드를 push한다.
2. 첫 번째 조건문을 통과 후 i가 0보다 크다면 right node에 대해 동일한 과정을 수행한다. i가 0 이하인 경우, 더이상 받아올 원소가 남아있지 않다는 것을 의미하기 때문에 더 이상 노드를 생성하지 않고 queue에 푸시하지 않는다.
3. queue에는 너비우선탐색모드로 왼쪽 -> 오른쪽 노드 순서대로 노드가 push 된다. 만약 i가 트리의 같은 level 상에서 가장 오른쪽에 해당하는 수 였다면,  이후 i + 1번째 루프에서 queue를 pop하면, i의 왼쪽 노드가 null이 아니었다는 가정하에
4. i의 left노드가 pop 될 것이고, 이는 너비우선탐색모드를 만족한다.

Conclusion
- 마지막 루프에 대해서도 위 특성을 만족하기 때문에, 길이 n인 입력에 대해 너비우선탐색으로 값이 저장된 완전이진트리를 만들어 줄 수 있다.

### 리프노드까지 합
InductiveHypothesis
- 높이가 i인 완전이진트리에서 모든 리프노드에 대해서 루트노드에서 각 리프노드까지의 합을 구해줄 수 있다면, 높이 i + 1의 완전이진트리에서도 값을 구해줄 수 있다.

BaseCase
- 원소가 하나인 완전이진트리에 대해 원소하나의 값은 그 자체로 루트노드에서 리프노드까지의 합이다.

InductiveStep
1. 높이 i의 완전이진트리에서 모든 리프노드에 대해서 루트노드에서 각 리프노드까지의 합을 구할 수 있다. 이때 리프노드가 완전히 채워져있다고 할때, 가장 왼쪽의 리프노드에 left 노드를 하나 만들어주면, i + 1 높이의 완전이진트리가 된다.
2. 높이 i + 1의 리프노드를 탐색했을 때, 첫번째 if에서 왼쪽 노드가 null이다. null이라면, temp에 저장된 값에 10을 곱하고 노드의 val을 더한 값을 result에 저장한다. temp에는 내려오면서 만난 노드의 val이 각 자리수에 맞게 저장되어있고,
3. 이번 노드에 대해서도 각 자리에 맞게 수정한 값을 result에 저장해준다. 나머지동작을 높이 i의 노드들에 대해서 수행하고 나면, 높이 i+1인 완전이진트리에 대해서도 모든 리프노드에 대해서 루트노드에서 각 리프노드까지의 합을 구해 줄 수 있음을 알 수 있다.

Conclusion
- 어떤 높이 i+1인 완전이진트리에서 모든 리프노드에 대해서 루트노드에서 각 리프노드까지의 합을 구해줄 수 있기 때문에, 높이 n의 완전이진트리에서도 값을 구해줄 수 있다.


>## Efficiency
### 완전이진트리 생성
- while반복문이 queue에 아무것도 들어있지 않을때까지 반복한다. 이때 queue에 push되는 크기는 input의 크기인 n값과 같다.
- while반복문 내에서 모든 과정은 상수 시간만큼 걸리므로 while내의 전체 시간은 약 12n정도로 보인다. 그리고 반복문 바깥의 수행 시간도 모두 상수 시간이므로 8정도로 보인다.
- 종합하면 while 내부와 외부를 합한 수행시간은 12n + 8이므로 ExpectedRuntime = O(n)으로 생각할 수 있다.

### 리프노드까지 합
- 재귀의 최고 높이는 log(n)+1이다. 그리고 leafnode의 수는 log(n)이다.
- 각 리프노드로 내려가면서 temp에 계속 값을 더하는 연산을 최고 높이만큼인 log(n)+1만큼 반복한다.
- 각 리프노드에서 올라가면서 temp에 계속 값을 나누는 연산을 최고 높이만큼인 log(n)+1만큼 반복한다.
- 리프노드가 총 log(n)개 만큼 있으므로 총 소요시간은 log(n) * 2(log(n) + 2)로 예상된다.
- 종합하면 총 수행시간은 2 * (log(n))^2 + 2log(n)이므로 ExpectedRuntime = O((log(n)^2))으로 생각할 수 있다.