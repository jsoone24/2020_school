# 시작점에서 목적지까지 경로의 수 구하기
>## input
1. 시작점은 (1,1)로 고정
2. main 함수의 pathCases(m, n)에 도착 좌표 입력
>## 알고리즘 설계 방법
1. 2차원 배열을 하나 만든다.
2. 입력의 크기에 도달할때까지 점점 경우의 수 계산을 늘려간다.
3. 입력에 대해 해당 지점의 값을 출력한다.

>## Correctness
LoopInvarient
- i번째 루프를 돌 때, 배열에서 i-1 * i-1 크기까지 각 지점으로 갈 수 있는 모든 경우의 수가 구해져있다.

InductiveHypothesis
- pathCases는 i번째 루프를 돌고 난 후 LoopInvarient를 만족한다.

BaseCase
- 입력 1, 1은 시작점이자 도착점이므로 1, 1에서 1, 1로 가는 경우의 수는 0가지다.

InductiveStep
1. 첫번째 루프에서 i번째 루프를 돌 때, LoopInvarient를 만족한다. 첫 번째 루프를 돌며 (0, i), (i ,0)의 값을 1로 초기화한다.
2. 안쪽 루프를 돌며, i-1번째 루프에서 배열의 각 모서리 끝으로 갈 수 있는 경우의 수로부터 i번째 루프에서 배열의 각 모서리 끝으로 갈 수 있는 경우의 수를 구한다.
3. 루프가 끝날 때, i * i 크기의 배열에 각 모서리까지 갈 수 있는 경우의 수가 배열에 계산되어 있다.

Conclusion
- max(n, m)번 루프를 돌고나면, max(n, m) * max(n, m) 번까지의 모든 경우의 수가 구해져있다.

>## efficiency
- 첫 번째 for문에서 max(n, m)번만큼 반복문을 수행한다. 3max(n,m)만큼의 시간이 소요된다.
- 두 번째 for문에서 max(n,m)*(max(n,m)+1)/2 번만큼 반복문을 수행한다. max(n,m)*(max(n,m)+1)/2 의 시간이 소요된다.
- 두 반복문에서 수행하는 명령어 수는 3max(n,m) + max(n,m)*(max(n,m)+1)/2 이다.
- 종합하면 WorstCase, Expected runtime은 O(max(n,m) ^ 2)으로 예상된다.